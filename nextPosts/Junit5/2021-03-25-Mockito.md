---
layout: customPost
title:  "Mockito"
categories: 
  - Spring
  - Test
---

##  Mockito What?

Mock이란 진짜 객체와 비슷한 동작을 하지만 개발자가 직접 행동을 관리하는 객체를 말하며, Mockito는 이러한 Mock 객체를 쉽게 만들고 관리하고 검증할 수 있는 방법을 제공하는 테스트 프레임워크입니다. Mockito 이외에도 JMock, EasyMock 등이 있습니다.

spring boot는 기본적으로  Mockito 및 테스트 관련 dependencies가 포함되어 있는 spring-boot-starter-test를 제공합니다. 단, spring boot 2.2 이후로  JUnit5, AssertJ 등이 포함되었기 때문에 현재 사용하고 계신 버전을 확인 하시고 해당 라이브러리가 없다면 직접 추가해서 사용해야 됩니다.

```
testImplementation 'org.springframework.boot:spring-boot-starter-test'
```

- JUnit5
- Spring Test
- AssertJ
- Hamcrest
- Mockito
- JsonPath
- JSONassert



## Mockito Why?

데이터베이스 또는 외부 API 등의 의존성을 배제한 단위 테스트를 하고자 할 때 사용합니다. ( TDD 개발 방법 포함)

예를들어 Product 코드의 Contoller 특정 메서드 내에서 Service나 Repository의 특정 메서드를 포함하고 있을 때, Controller의 특정 메서드를 테스트 하려면 내부에 포함되어 있는 Service나 Repository를 구현한 다음 테스트를 진행 해야 됩니다.  Product에 구현되어 있는 것과 별개로 테스트 코드에서는 Controller가 의존하고 있는 객체들을 Mocking(가짜 객체로 만듬)하므로서 의존성을 배제할 수 있습니다. 뿐만 아니라 Mocking된 객체들의 메서드를 호출할 때 특정 조건(예: parameter가 3일 때)과 리턴 값(예: return 10을 해라)을 내 임의로 설정 한다던지, 특정 메소드의 호출 여부 등을 검사할 수도 있습니다. 이처럼 Controller나 Service, Repository 등의 단위 테스트를 할 때 사용할 수 있는 유용한 Java용 오픈 소스 테스트 프레임워크입니다.



## Mockito How?

Mock 객체를 Mocking하는 방법은 mock() 메서드를 사용하거나 @Mock, @Spy, @InjectMocks 등의 Annotation을 사용하고 Mockito에서 제공하는 Mock 객체들을 초기화 해주는 방법을 사용해야 합니다.



### Mock을 초기화하는 3가지 방법

- **MockitoAnnotations.openMocks(this);** 

  ```java
  public class ControllerTest {
      private AutoCloseable closeable;
      
      @Mock
      Service service;
      
      @BeforeEach
      public void openMocks() {
          closeable = MockitoAnnotations.openMocks(this);
      }
  	
      //...
      
      @AfterEach
      public void releaseMocks() throws Exception {
          closeable.close();
      }
  }
  ```

- **@ExtendWith(MockitoExtension.class)   테스트 클래스에 Annotated 합니다.**

  ```java
  @ExtendWith(MockitoExtension.class)
  class ControllerTest {
      @Mock
      Service service;
      
      //...
  }
  ```

  MockitoExtension의 기본 설정은 Strictness.STRICT_STUBS이며 아래와 같은 기능을 합니다.

  > 생산성 향상: 테스트 대상 코드가 다른 인수를 사용하여 스텁 메서드를 호출하면 테스트가 조기에 실패합니다.

  > 불필요한 스텁이 없는 클리너 테스트: 사용되지 않은 스텁이 있으면 테스트가 실패함.

  > 스텁된 호출을 더 이상 명시적으로 확인할 필요가 없습니다.

  세션을 초기화 하기 위해 새로운 MockitoSession 인스턴스를 만듭니다.  이때 @Mock, @Spy, @InjectMocks등으로 Annotated된 객체(필드)들은 initMocks() 메서드에 의해 (STRICT_STUBS 기반으로) 초기화 됩니다.

  Strictness의 값을 변경하려면 아래와 같이 Annotation을 추가하면 됩니다.

  ```java
  @MockitoSettings(strictness = Strictness.STRICT_STUBS)
  @ExtendWith(MockitoExtension.class)
  class ControllerTest {
  ```

  

- **@Rule public MockitoRule mockito = MockitoJUnit.rule();**

  MockitoRule는 mock을 초기화하고 사용을 검증하며 잘못된 스텁을 감지하며 초기화 방법 중 제일 무난한 방법이라고 생각합니다.
  
  > 스텁 인수 불일치를 자동으로 감지하고 Strictness(엄격성?)으로 규칙을 구성합니다.
  >
  > MockitoJUnitRunner 대신 JUnit Rule을 사용할 수 있고 JUnit 4.7이상이 필요합니다.
  >
  > Mockito Annotation이 달린 mock을 초기화 합니다.
  >
  > MockitoJUnit.rule()의 default Strictness는 Strictness.WARN입니다.
  >
  > MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS); 형식으로 Strictness를 변경할 수 있습니다.

  ```java
  class ControllerTest {
      @Rule
      public MockitoRule mockito = MockitoJUnit.rule();
      
      @Mock
      Service service;
      
   	//...   
  }
  ```

  참고: MockitoJUnit 내부를 따라 가보면 MockitoExtension 처럼 MockitoSession 인스턴스를 만드는 메소드를 포함하고 있습니다.

  ![image-20210401143124692](C:\Users\webme\mygit\blog\assets\images\posts\image-20210401143124692.png)



## Mockito Annotation

### @Mock

@Mock을 Annotated하면 Mockito가 초기화할 때 대상을 스캔하여 Mock 객체로 만들어 줍니다.

Mock객체는 실제 Product를 참조하지 않기 때문에 Mock객체의 메서드를 호출하지 않고, Test 코드에서 when으로 할당한 값이 리턴 됩니다.

mockitoController.java

```java
private final TestService testService;
public MockitoController(TestService testService) {
    this.testService = testService; //testService: testService
}

@GetMapping("/example3")
public Integer example3(Integer value) {
    //첫번째 호출 resultValue: 0, 두번째 호출 resultValue: 10
    Integer resultValue = testService.calculateValue(value); 
    return resultValue;
}
```

```java
public int calculateValue (int value) { 
    return value * 2; //실행 안됨.
}
```

Test.java

```java
@Mock
TestService testService;

@InjectMocks
MockitoController mockitoController;

//...

final int value = 3;

this.mockMvc.perform(get("/example3").param("value", String.valueOf(value)));

when(this.testService.calculateValue(value)).thenReturn(10);

this.mockMvc.perform(get("/example3").param("value", String.valueOf(value)));
```



### **@Spy**

테스트할 객체 중 특정 객체만 선택적으로 실제 객체로 테스트할 수 있게 해줍니다.

위에서 사용한 테스트 예제에서 @Mock을 @Spy로 바꾸면 어떻게 결과가 달라지는지 보여줍니다.

한가지 특이한점은 @Spy 객체의 메서드가 두번 모두 호출되었는데, 첫번째는 3*2가되어 6으로 나오지만, 

두번째는 호출전 테스트코드에서 작성한 when(...) thenReturn(10);의 영향으로 10이 나오는걸 확인할 수 있습니다. 이 결과로 알 수 있는 것은 실제 객체의 메서드가 호출 되지만 Mockito의 예상값을 지정하면 그 값으로 오버라이드 된 값이 나온다는 것을 알 수 있었습니다.

mockitoController.java

```java
private final TestService testService;
public MockitoController(TestService testService) {
    this.testService = testService; 
    //testService: com.example.tdd1.TestService$MockitoMock$1712051045@6f5d90f7
}

@GetMapping("/example3")
public Integer example3(Integer value) {
    //첫번째 호출 resultValue: 6, 두번째 호출 resultValue: 10
    Integer resultValue = testService.calculateValue(value); 
    return resultValue;
}
```

```java
public int calculateValue (int value) { 
    return value * 2; //첫번째, 두번째 모두 호출됨.
}
```

Test.java

```java
@Mock
TestService testService;

@InjectMocks
MockitoController mockitoController;

//...

final int value = 3;

this.mockMvc.perform(get("/example3").param("value", String.valueOf(value)));

when(this.testService.calculateValue(value)).thenReturn(10);

this.mockMvc.perform(get("/example3").param("value", String.valueOf(value)));
```



### @InjectMocks

@InjectMocks로 Annotated된 객체에 생성자 Injection 등으로 DI가 필요한 경우, ExtensionContext.getRequiredTestInstances().getAllInstances()에서  @Mock, @Spy 등으로 Annotated되어 Mocking된 객체를 찾아서 DI 해줍니다.  

아래 예제는 MockitoController에 Injection 대상 mockitoService, testService를 자동으로 Mock객체를 DI 해주는 예제 입니다.



MockitoController.java

```java
private final MockitoService mockitoService;
private final TestService testService;

public MockitoController(MockitoService mockitoService, TestService testService) {
    this.mockitoService = mockitoService;
    this.testService = testService;
}
```

Test.java

```java
//직접 객체를 생성하고 Dependency Injection을 수동으로 하는 방법 
this.mockMvc = MockMvcBuilders.standaloneSetup(new MockitoController(mockitoService, testService)).build();

@Mock
MockitoService mockitoService;

@Spy
TestService testService;

//@InjectMocks을 이용하는 방법
@InjectMocks
MockitoController mockitoController;

this.mockMvc = MockMvcBuilders.standaloneSetup(mockitoController).build();

```



### @SpyBean

### @MockBean

```java
import org.springframework.boot.test.mock.mockito.MockBean;
```





**속성값**

answer: 상호 작용에 대한 기본 대답을 지정합니다.

```java
Answers answer() default Answers.RETURNS_DEFAULTS;
예)
Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));
         Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));
      
//Below does exactly the same:
Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
```

stubOnly : 스텁 전용 모의는 메서드 호출을 기록하지 않으므로 메모리를 저장하지만 호출 확인을 허용하지 않습니다.

```java
boolean stubOnly() default false;
예)
List stubOnly = mock(List.class, withSettings().stubOnly());
```

name: 이름을 지정합니다.

```java
String name() default "";
예)
Foo foo = mock(Foo.class, withSettings().name("foo"));
      
//Below does exactly the same:
Foo foo = mock(Foo.class, "foo");
```

extraInterfaces: 모크가 구현해야 하는 추가 인터페이스를 지정합니다. 

```java
Class<?>[] extraInterfaces() default {};

예) 
Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));
      
//now, the mock implements extra interfaces, so following casting is possible:
Bar bar = (Bar) foo;
Baz baz = (Baz) foo;
```

serializable: Mock 직렬화 여부.

```java
boolean serializable() default false;

예) 
List serializableMock = mock(List.class, withSettings().serializable());
```

lenient: 엄격한 유효성검사를 생략할지 여부.

```java
boolean lenient() default false;

예)
Foo mock = mock(Foo.class, withSettings.lenient());
```























@MockBean은 ApplicationContext(loc Container)에 mock객체를 추가합니다. 그리고 추가된 mock객체는 같은 type의 bean을 대신합니다.



mockito 를 사용할 때는 **org.mockito.Mockito.\*; 로 static import** 를 하는 것이 추천된다.

그렇지 않으면 함수 호출시마다 Mockito.mock() 과 같이 class 이름을 계속 붙여주어야 한다

when thenReturn 과 when thenThrow 와 비슷한 **doReturn when 과 doThrow when 이 있다.**

**when thenXXX 은 mock 과 작업할 때 사용하고, doXXX when 은 spy 와 함께 사용할 때 사용한다.**

spy 는 나중에 나오지만, mock 이 아닌 진짜 object 를 상대로 api 호출하도록 할 때 사용되는 녀석이다

```java
when(calcService.add(20.0,10.0)).thenAnswer(new Answer<Double>(){
    @Override
    public Double answer(InvocationOnMock invocation) throws Throwable {
        Object[] args = invocation.getArguments();
        Object mock = invocation.getMock();
        // do something with args & mock
        return 30.0;
    }
}
```







## Example

MockitoController.java

```java
package com.example.tdd1;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@Slf4j
public class MockitoController {

    private final MockitoService mockitoService;

    public MockitoController(MockitoService mockitoService) {
        this.mockitoService = mockitoService;
    }

    @GetMapping("/example1")
    public Integer example1(Integer value1, Integer value2) {
        return this.mockitoService.calculateValue(value1, value2);
    }

    @GetMapping("/example2")
    public List<MockitoDto> example2(MockitoDto dto) {
        return this.mockitoService.getDataList(dto);
    }
}

```

MockitoDto.java

```java
package com.example.tdd1;

import lombok.*;

@Getter
@Setter
@ToString
@NoArgsConstructor
@EqualsAndHashCode(of = {"name", "value1", "value2"})
public class MockitoDto {
    private String name;
    private Integer value1;
    private Integer value2;

    @Builder
    public MockitoDto(String name, Integer value1, Integer value2) {
        this.name = name;
        this.value1 = value1;
        this.value2 = value2;
    }
}
```

MockitoService.java

```java
package com.example.tdd1;

import java.util.List;

public interface MockitoService {
    public List<MockitoDto> getDataList(MockitoDto dto);
    
    public int calculateValue(int a, int b);
}
```

MockitoControllerTest.java

```java
package com.example.tdd1;


import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit.jupiter.web.SpringJUnitWebConfig;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.log;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringJUnitWebConfig
@ExtendWith(MockitoExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@Slf4j
class MockitoControllerTest {
    MockMvc mockMvc;
    ObjectMapper objectMapper;
    
    @Mock
    MockitoService mockitoService;
    
    AutoCloseable closeable;

    @BeforeAll
    public void openMocks() {
        closeable = MockitoAnnotations.openMocks(this);
    }

    @BeforeEach
    void setUp() {
        this.objectMapper = new ObjectMapper();
        //this.mockitoService = mock(MockitoService.class);
        this.mockMvc = MockMvcBuilders.standaloneSetup(new MockitoController(mockitoService))
                .alwaysDo(log())
                .build();
    }

    @Test
    @DisplayName("mockito 기본 테스트")
    void test1() throws Exception {
        //given
        final int value1 = 3;
        final int value2 = 5;

        Mockito.when(this.mockitoService.calculateValue(value1, value2)).thenReturn(value1 * value2);

        //when
        MvcResult mvcResult = this.mockMvc.perform(get("/example1")
                .param("value1", String.valueOf(value1))
                .param("value2", String.valueOf(value2))).andReturn();

        //then
        Mockito.verify(this.mockitoService).calculateValue(value1, value2);
        Assertions.assertEquals(mvcResult.getResponse().getContentAsString(), String.valueOf(value1 * value2));
    }

    @Test
    @DisplayName("Mockito Answer 테스트")
    void test2() throws Exception {
        //given
        final MockitoDto dto = MockitoDto.builder()
                .value1(2)
                .value2(3)
                .name("spring")
                .build();

       List<MockitoDto> resultList = Arrays.asList(dto, dto, dto);
//        Mockito.when(this.mockitoService.getDataList(Mockito.isA(MockitoDto.class))).thenReturn(resultList);
        Mockito.when(this.mockitoService.getDataList(Mockito.isA(MockitoDto.class))).then(invocation -> {
            log.info("answer call!");
            return resultList;
        });

        //when
        ResultActions resultActions = this.mockMvc.perform(get("/example2")
                .params(convertDtoToMultiValueMap(objectMapper, dto))
                .contentType(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON));

        //then
        resultActions.andExpect(status().isOk()); //http 상태코드 200(정상)인지 검사.
        resultActions.andExpect(jsonPath("$.[*].name", Matchers.everyItem(Matchers.notNullValue()))); //리턴 받은 json객체의 name필드 중 null값이 포함되어있는지 검사.

        ArgumentCaptor<MockitoDto> captor = ArgumentCaptor.forClass(MockitoDto.class);
        Mockito.verify(this.mockitoService).getDataList(captor.capture()); //호출된 메소드에 전달된 값 검증하기 (메소드 1번만 호출 허용)
        Assertions.assertEquals(dto, captor.getValue());

        /*
            public static <T> T verify(T mock, VerificationMode mode)
            public interface VerificationMode
            public class VerificationModeFactory
            public class Times implements VerificationInOrderMode, VerificationMode
         */
        Mockito.verify(this.mockitoService).getDataList(Mockito.isA(MockitoDto.class)); // 1번만 호출되었는지 검사
        Mockito.verify(this.mockitoService, Mockito.times(1)).getDataList(Mockito.isA(MockitoDto.class)); // 지정된 호출횟수 만큼 호출되었는지 검사
        Mockito.verify(this.mockitoService, Mockito.timeout(1)).getDataList(Mockito.isA(MockitoDto.class)); //비동기 코드를 테스트 시 지정된 시간 내에 메소드가 처리되는지
    }

    @AfterAll
    public void releaseMocks() throws Exception {
        closeable.close();
    }

    MultiValueMap<String, String> convertDtoToMultiValueMap(ObjectMapper objectMapper, Object dto) {
        try {
            MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
            params.setAll(objectMapper.convertValue(dto, new TypeReference<Map<String, String>>() {
            }));
            return params;
        } catch (Exception e) {
            throw new IllegalStateException("Url Parameter Convert Error");
        }
    }
}
```















