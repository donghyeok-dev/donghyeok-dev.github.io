---
layout: customPost
title:  "Design Pattern"
categories: 
  - Java
  - Design
  
toc: true
toc_label: "List"
toc_sticky: true 
---
## 1. 커맨드

- Runnable 인터페이스 처럼 객체를 생성할 때 계산에 필요한 모든 매개 변수를 초기화 한다.

  호출 준비가 되면 run()과 같은 프로토콜을 이용해서 계산을 호출 한다.



## 2. 값 객체

- 생성 후 절대 변할 수 없도록 설정한다.

- 수행되는 연산은 언제나 새로운 객체를 반환하게 만든다.

- 동등성(equals)과 해싱(hashCode)를 구해야(오버라이딩) 한다.

- 두 객체가 제3의 객체에 대한 참조를 공유하고 있을 때, 한 객체가 공유되는 객체의 상태를 변화시키면 나머지 다른

-  객체가 참조가 하고 있는 공유 객체의 값이 변화 된다. 이게 바로 고전적 별칭 문제이다.

- 별칭 문제 해결 방안

  - 의존하는 객체에 대한 참조를 외부에 알리지 않는 대신 객체에 대한 복사본을 제공.

    (수행시간이나 메모리 공간 측면에서 비싼 해결책.)

  - 옵저버 패턴 사용: 의존하는 객체에 자기를 동록해 놓고 객체의 상태가 변하면 통지를 받는 방법이다. 옵저버 패턴은 제어 흐름을 이해하기 어렵게 만들 수 있고, 의존성을 설정하고 제거하기 위한 로직이 지저분해질 수 있다.

  - 값 객체 할당을 사용.

- 동일성(identity)와 동등성(equality)는 서로 다르다. 5백원 동전 두개가 서로 동등할지라도 동일하지는 않다.



## 3. 널 객체

- 