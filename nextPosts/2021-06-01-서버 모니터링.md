---
layout: customPost
title:  "서버 모니터링"
categories: 
  - Monitoring
  - Server

---
# 서버 모니터링

서비스의 품질에 있어 성능 이슈나 장애로 인해 고객이 불편을 겪지 않도록 하는 것은 매우 중요하기 때문에 장애에 대한 예방과 대응 측면에서 서비스가 실행 중인 서버에 대한 모니터링이 필수 입니다. 

개발자나 운영팀에서 많은 서버들의 상태를 24시간 감시할수 없기 때문에  고객을 통해 장애를 인지하는 경우가 많고 그 만큼 서비스 중단 시간이 길어집니다. 서비스의 중단 시간이나 빈도가 많아질 수록 기업의 신뢰도가 낮아집니다. 이러한 문제를 해결하기 위해서는 자동화된 모니터링 시스템을 통해 경고나 장애의 알람을 받고 대응하여 서비스의 중단을 최소화 시켜야 합니다.

모니터링을 통해 수집된 정보를 토대로 서버의 증설 유무나 인프라 계획을 수립할 수 있습니다. 데이터를 기반으로 의사결정이 가능하기 때문에 좀 더 정확한 의사결정을 할 수 있습니다.

추가적으로 모니터링과 더불어 인프라적인 failOver나 장애 발생를 유발할 수 있는 개발 코드 검증도 필요 합니다. 

---

# 서버 모니터링 솔루션 선택

시중에 많은 유료와 오픈소스 기반의 모니터링 솔루션들이 있습니다. 

그 중 아래와 같은 조건으로 prometheus를 선택하였습니다. (prometheus 외에도 오픈소스 솔루션으로  sensu, fluentd  등이 있습니다.)

- 오픈소스 
- 다양한 서버에서 CPU, Memory, Disk, Traffic, Process, JVM 등 정보를 수집
- 대중적이고 커뮤니티 활성화
- 분산 스토리지에 의존하지 않음
- 자동 알림을 제공
- time series data 기반 솔루션 (시계열이라 불리는 time series data는 현재와 과거 시간의 데이터를 비교할수 있는 방식의 값을 말함)

---

# prometheus(프로메테우스)

 https://prometheus.io/

Prometheus server에서 각 노드(서버)들에 접근하여 각 노드들이 수집한 정보들을 가져오는(pull) 방식으로 구성되어 있습니다.

<img src="C:\Users\webme\mygit\blog\assets\images\posts\image-20210601134719844.png" alt="image-20210601134719844" style="zoom:150%;" />

### Component

Client Libraries - 응용 프로그램 코드를 계측하기 위한 클라이언트 라이브러리

Prometheus Server - 이벤트를 수집하고 시계열 데이터로 저장

Pushgateway - job을 import하여 단기간에 생성되었다가 사라지는 데이터를 지원

Job exporters - HAProxy, StatsD, Graphite와 같은 서비스로 보냄 (https://prometheus.io/docs/instrumenting/exporters/)

Alertmanager - 알람 

### Features

SoundCloud에서 제작된 오픈소스시스템 모니터링 및 알림 툴킷.

메트릭 이름 및 키/값 쌍으로 식별된 시계열 데이터를 포함하는 다중 차원 데이터 모델.(LevelDB)

다차원 차원성을 활용할 수 있는 유연한 쿼리 언어(PromQL)

분산 스토리지에 의존하지 않음.

시계열 수집은 HTTP를 통한 pull 모델을 통해 수행.

그래프 작성 및 대시보드 지원의 여러 가지 모드

모니터링 노드에 설치된 Prometheus는 Web API로 연결되어 각 노드를 브라우저에서 직접 참조

### Support

Linux, Windows OS

> .NET, C++, Go, Haskell, Java, Node.js, Python, Ruby
>
> sharding
>
> federation Replication

RESTful HTTP and JSON

---

# Prometheus Server 시작하기

다운로드

 wget https://github.com/prometheus/prometheus/releases/download/v2.27.1/prometheus-2.27.1.linux-amd64.tar.gz

#cd prometheus-2.27.1.linux-amd64/

#vim prometheus.yml

```yaml
# my global config
global:
  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).

# Alertmanager configuration
alerting:
  alertmanagers:
  - static_configs:
    - targets:
      # - alertmanager:9093

# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: 'prometheus'

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
    - targets: ['localhost:9090']
```



global (기본적인 전역설정)

- scrape_interval : 얼마나 자주 메트릭(targets)을 수집할지 설정. 기본 1분
- evaluation_interval : 얼마나 자주 규칙(rules)을 평가할지 설정. 기본 1분

scrape_configs (메트릭을 수집할 엔드포인트로 여기서는 prometheus 서버 자신을 가리키는 설정을 했다. 여러개 설정이 가능하다.)

- job_name : 잡 이름 설정
- static_config : 긁어하는 방법에 대한 목표 및 파라미터 세트를 지정.

static_configs: targets 속성으로 여러개의 수집 서버를 지정할 수 있고 localhost:9090는 prometheus server를 수집하는 설정입니다. (자기 자신을)



prometheus 실행

#./prometheus
level=info ts=2021-06-01T06:42:33.890Z caller=main.go:388 msg="No time or size retention was set so using the default time retention" duration=15d
level=info ts=2021-06-01T06:42:33.890Z caller=main.go:426 msg="Starting Prometheus" version="(version=2.27.1, branch=HEAD, revision=db7f0bcec27bd8aeebad6b08ac849516efa9ae02)"
level=info ts=2021-06-01T06:42:33.890Z caller=main.go:431 build_context="(go=go1.16.4, user=root@fd804fbd4f25, date=20210518-14:17:54)"
level=info ts=2021-06-01T06:42:33.890Z caller=main.go:432 host_details="(Linux 3.10.0-1160.25.1.el7.x86_64 #1 SMP Wed Apr 28 21:49:45 UTC 2021 x86_64 localhost.localdomain (none))"
level=info ts=2021-06-01T06:42:33.890Z caller=main.go:433 fd_limits="(soft=1024, hard=4096)"
level=info ts=2021-06-01T06:42:33.890Z caller=main.go:434 vm_limits="(soft=unlimited, hard=unlimited)"
level=info ts=2021-06-01T06:42:33.892Z caller=web.go:540 component=web msg="Start listening for connections" address=0.0.0.0:9090
level=info ts=2021-06-01T06:42:33.893Z caller=main.go:803 msg="Starting TSDB ..."
level=info ts=2021-06-01T06:42:33.894Z caller=tls_config.go:191 component=web msg="TLS is disabled." http2=false
level=info ts=2021-06-01T06:42:33.899Z caller=head.go:741 component=tsdb msg="Replaying on-disk memory mappable chunks if any"
level=info ts=2021-06-01T06:42:33.899Z caller=head.go:755 component=tsdb msg="On-disk memory mappable chunks replay completed" duration=7.289µs
level=info ts=2021-06-01T06:42:33.899Z caller=head.go:761 component=tsdb msg="Replaying WAL, this may take a while"
level=info ts=2021-06-01T06:42:33.899Z caller=head.go:813 component=tsdb msg="WAL segment loaded" segment=0 maxSegment=0
level=info ts=2021-06-01T06:42:33.899Z caller=head.go:818 component=tsdb msg="WAL replay completed" checkpoint_replay_duration=24.286µs wal_replay_duration=222.95µs total_replay_duration=273.315µs
level=info ts=2021-06-01T06:42:33.901Z caller=main.go:828 fs_type=XFS_SUPER_MAGIC
level=info ts=2021-06-01T06:42:33.901Z caller=main.go:831 msg="TSDB started"
level=info ts=2021-06-01T06:42:33.901Z caller=main.go:957 msg="Loading configuration file" filename=prometheus.yml
level=info ts=2021-06-01T06:42:33.902Z caller=main.go:988 msg="Completed loading of configuration file" filename=prometheus.yml totalDuration=741.714µs remote_storage=4.106µs web_handler=376ns query_engine=717ns scrape=355.748µs scrape_sd=34.963µs notify=43.975µs notify_sd=22.227µs rules=3.74µs
level=info ts=2021-06-01T06:42:33.902Z caller=main.go:775 msg="Server is ready to receive web requests."



방화벽을 열어줍니다.

---

참고:

https://owlyr.tistory.com/24