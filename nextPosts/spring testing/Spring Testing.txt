1. 단위 테스트(Unit Testing)

영속(영구) 데이터를 액세스하지 않고 테스트를 하려면
서비스 레이어 객체를 스텁하거나 Dao 또는 레파지토리 인터페이스를 mocking하여 테스트할 수 있습니다.

1.1 Mock 객체

-Environment
	org.springframework.mock.env 패키지에는 Environment과 PropertySource 추상화의 모의 구현이 포함되어 있습니다.
	MockEnvironment와 MockPropertySource 는 환경별 특성에 의존하는 코드를 테스트 하는데 유용합니다.

-JNDI
	org.springframework.mock.jndi 패키지에는 JNDI SPI의 부분적인 구현을 포함하고, 
	간단한 독립 실행형 애플리케이션을 위한 JNDI 환경을 설정하는데 사용할 수 있습니다.
	예를 들어 JDBC DataSource 인스턴스가 Java EE 컨테이너에서와 동일한 JNDI 이름에 바인딩되면 
	수정 없이 애플리케이션 코드와 구성을 테스트 시나리오에서 모두 재사용할 수 있습니다.
	또한 org.springframework.mock.jndi 패키지는 Spring Framework 5.2 이후부터 Simple-JNDI와 같은 3rd part 솔루션을  지원하지 않습니다.
  
-Servlet API
	org.springframework.mock.web 패키지에는 웹 컨텍스트, 컨트롤러 및 필터 테스트에 
	유용한 Servlet API 모의 객체들이 포함되어 있습니다. 모의 객체들은 Spring Web MVC Framework에서의 사용을 목표로 하며
	일반적으로 동적 모의 객체(EasyMock), 대체 Servlet API 모의 객체보다 사용이 편리합니다.
	Spring Framework 5.0 이후부터 org.springframework.mock.web 패키지의 모의 객체는 Servlet 4.0 API를 기반으로 합니다.
  스프링 MVC에 대한 통합 테스트 프레임워크를 제공하기 위해 모의 서블릿 API 객체를 기반으로 구축됩니다. (MockMvc를 참조)

-Spring Web Reactive
  org.springframework.mock.http.server.reactive 패키지에는 WebFlux 애플리케이션에서 사용하는
  ServerHttpRequest, ServerHttpResponse의 모의 구현이 포함되어 있습니다.
  org.springframework.mock.web.server 패키지에는 이러한 모의 요청 및 응답 개체에 따라 달라지는
  모의 서버 웹 Exchange가 포함되어 있습니다.
  MockServerHttpRequest, MockServerHttpResponse는 모든 서버별 구현과 동일한 추상 기본 클래스에서 확장되어 동작을 공유합니다.
  예를들어 모의 요청은 변경할 수 없는 인스턴스로 만들어지지만 mutate() 메소드를 사용하면 
  ServerHttpRequest의 수정된 인스턴스를 만들 수 있습니다.
  WebTest Client는 HTTP 서버 없이 WebFlux 응용 프로그램을 테스트할 수 있도록 모의 요청 및 응답을 기반으로 합니다. 
  클라이언트는 실행 중인 서버의 종단 간 테스트에도 사용할 수 있습니다.


1.2 단위 테스트 지원 클래스
- 일반 테스트 유틸리티
  org.springframework.test.util 패키지에는 단위 및 통합 테스트에 사용하기 위한 몇 가지 범용 유틸리티가 포함되어 있습니다.
  
  ReflectionTestUtils은 Relection을 기반으로 하는 유틸 메서드들의 collection입니다. 
  애플리케이션 코드를 테스트할 때 상수의 값을 변경하거나 
  non-pulbic 필드, 메서드, 설정, 라이프사이클 콜백 메서드를 invoke하는 테스트 시나리오에서 사용할 수 있습니다.
  - ORM Framework(JPA, Hibernate 같은)에서 도메인 엔티티의 private나 protected 필드에 접근을 허용합니다.
  - Spring은 private나 protected의 필드, Setter메서드, 설정 메서드들에 대해 종속성 주입을 위한 
    @Autowired, @Inject, @Resource와 같은 Annotation을 지원합니다.
  - 라이프 사이클 콜백 메서드에 @PostConstruct과 @PreDestroy와 같은 Annotation을 사용합니다.

  AopTestUtils은 AOP와 관련된 유틸리티 메서들의 collection입니다.
  AopTestUtils를 사용하면 Spring 프록시 뒤에 숨겨진 하나 이상의 기본 대상 객체에 대한 참조를 가져올 수 있습니다.
  예를들어 EasyMock이나 Mockito와 같은 라이브러리를 활용해 설정한 동적 Mock을 Spring 프록시에 wrapped한 경우 
  Mock 객체에 직접 접근하여 expectations(예측)를 설정해야 할 필요가 있습니다.
  Spring의 core AOP 유틸리티는 AopUtils와 AopProxyUtils를 참조하세요.


  리플렉션이란 객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법을 말한다. 
  클래스의 정보로 클래스의 필드와 메소드 등을 이용할 수 있다.

- 스프링 MVC 테스트 유틸리티
  org.springframework.test.web 패키지에는 Spring MVC ModelAndView 객체를 단위 테스트하기 위한  
  JUNit, TestNG 또는 기타 테스트 프레임워크와 함께 사용할 수 있는 ModelAndViewAssert가 포함되어 있습니다.
  스프링 MVC 컨트롤러  POJO 클래스를 단위 테스트하려면 스프링 API mocks의 MockHttpServletRequest, MockHttpSession 등과 
  ModelAndViewAssert를 조합해서 사용하세요. 
  스프링 MVC WebApplicationContext로 구성된 스프링 MVC와 REST Controller 클래스를 통합 테스트하려면 
  스프링 MVC 테스트 프레임워크(MockMvc)를 사용하십시오.



2. Integration Testing(통합 테스트)

애플리케이션 서버를 구축하거나 다른 엔터프라이즈 인프라에 연결하지 않고도 일부 통합테스트를 수행할 수 있어야 합니다.
- 스프링 IoC 컨테이너 컨텍스트를 올바르게 wiring합니다.
- JDBC 또는 ORM 툴를 사용하여 데이터를 엑세스 합니다. 여기에는 sql문 hibernate 쿼리, JPA 엔티티 매핑 등이 포함될 수 있습니다.

와이어링(wiring)이란 객체간의 관계 형성 작업으로 DI 개념의 핵심입니다. 예를들어 스프링 컨테이너에 등록된 A,B,C 객체가 있다고 가정하고,
D객체가 B와 C객체를 참조하려할때 D객체에서 @Autowired Annotation을 사용하여 B, C 객체를 Inject 받을 수 있습니다.
와이어링 하는 방법은 여러가지 방법이 있는데 자세한건 검색 해보시길 바랍니다.

org.springframework.test 패키지에는 스프링 컨테이너와 통합 테스트를 위한 유용한 클래스들이 포함되어 있습니다. 
이 테스트는 애플리케이션 서버 또는 다른 배포환경에 의존하지 않기 때문에 
애플리케이션 서버에 의존하는 동등한 Selenium 테스트 또는 원격 테스트 보다 훨씬 빠릅니다.
단위 및 통합 테스트 스프링 테스트 프레임워크의 Annotation 위주로 지원됩니다.
테스트 컨텍스트 프레임워크는 사용 중인 실제 테스트 프레임워크와는 무관하며 이를 통해 JUnit, TestNG 등 다양한 환경에서 테스트를 할 수 있습니다.

2.1 통합 테스트 목표
- 테스트 간 Spring Ioc 컨테이너 캐싱을 관리합니다.
   Spring Test Context Framework는 Spring ApplicationContext와 WebApplicationContext의 일관된 로드를 제공하고 이러한 컨텍스트의 캐싱을 제공합니다.
   시작 시간이 문제가 될 수 있기 때문에 로드된 컨텍스트를 캐쉬하는 지원이 중요합니다. 이는 스프링 자체의 오버헤드가 아니라 스프링 컨테이너에 의해 생성된 객체를 인스턴스화 하는데 시간이 걸리기 때문입니다.
   기본적으로 로드가 되면 구성된 ApplicationContext가 각 테스트에 재사용됩니다. 따라서 처음 한번 이후 테스트 실행 속도는 빨라집니다.
- 테스트 픽스처 DI(Test Fixtures Dependency Injection)
  테스트 컨텍스트 프레임워크는 응용 프로그램 컨텍스트를 로드할 때 종속성 주입을 사용하여 테스트 클래스의 인스턴스를 선택적으로 구성할 수 있고, 
  응용프로그램 컨텍스트에 미리 구성된 빈(스프링 관리 개체 그래프, 트랜잭션 프록시, 데이터 소스 인스턴스 등)에서 
  컨텍스트를 재사용할 수 있기 때문에 개별 테스트에 대해 복잡한 복제를 할 필요가 없습니다.
- 통합테스트에 적합한 트랜잭션 관리를 제공합니다.
  테스트에서 트랜잭션 프록시 개체를 호출하면 테스트 컨텍스트 프레임워크는 각 테스트에 대한 트랜잭션을 만들고 
  구성된 트랜잭션 의미에 따라 올바르게 동작하도록 합니다.
  또한 테스트에 대해 관리되는 트랜잭션 내에서 실행되는 동안 선택한 테이블의 내용을 삭제하면 
  기본적으로 트랜잭션이 롤백되고 테스트 실행 전에 데이터베이스가 해당 상태로 돌아갑니다.
  트랜잭션 지원은 테스트의 애플리케이션 컨텍스트에 정의된 PlatformTransaction Manager를 사용하여 테스트에 제공됩니다.
  
  만약 트랜잭션이 커밋되길 원한다면 @Commit Annotation을 사용하여 동작하도록 할 수 있습니다.
  
- 통합 테스트 작성 시 개발자를 지원하는 Spring 별 기본 클래스를 제공합니다.
ApplicationContext는 명시적 검색을 수행하거나 전체 컨텍스트의 상태를 테스트 하기 위한 것입니다.
JdbcTemplate는 SQL문을 용프로그램과 동일한 트랜잭션 범위에서 실행하고 실행 전, 후에 모든 데이터베이스 상태를 확인할 수 있습니다.

2.2 JDBC Testing Support
org.springframework.test.jdbc 패키지에는 표준 데이터베이스 테스트 시나리오를 단순화 하기 위한 JDBC 관련 유틸리티 메서드를 제공하는 JdbcTestUtils가 포함되어 있습니다.
countRowsInTable : 지정된 테이블의 행 수를 카운트합니다.
countRowsInTableWhere : 지정된 표에서 모든 행을 삭제합니다.
deleteFromTables : 지정된 표에서 모든 행을 삭제합니다.
deleteFromTableWhere : 지정된 WHERE 절을 사용하여 지정된 테이블에서 행을 삭제합니다.
dropTables : 지정된 테이블을 삭제 합니다.
spring-jdbc 모듈은 내장형 데이터베이스 지원 및 내장형 데이터베이스에서 데이터 액세스 로직 테스트를 지원합니다.


2.3 Annotations

- 스프링 테스트 Annotation
@BootstrapWith : 클래스 Annotation이고, 컨텍스트 프레임워크의 부트스트랩 방법을 구성하는 데 사용. 

@ContextConfiguration : ApplicationContext를 로드 및 구성하는 방법을 결정하는 데 사용되는 클래스 수준 메타데이터를 정의. 
						일반적으로 @Configuration 클래스 이외에도 @Component, @Service, xml, groovy 등도 될 수 있습니다.

@WebAppConfiguration: WebApplicationContext 임을 선언. src/main/webapp의 기본값을 사용하여 테스트를 위한 WebApplication Context가 로드되고,
					  리소스 기본 경로는 씬(scene) 뒤에서 테스트의 웹 응용 프로그램 컨텍스트에 대한 서블릿 컨텍스트 역할을 하는 MockServlet Context를 만드는 데 사용됩니다.
@ContextHierarchy: 클래스 Annotation이고, 하나 이상의 @ContextConfiguration인스턴스 목록으로 선언되어야하며, 각 인스턴스는 컨텍스트 계층 구조의 수준을 정의합니다. 

@ActiveProfiles : 활성화되어야하는 Bean 정의 프로파일을 선언.

@TestPropertySource : 클래스 Annotation이고, 속성의 파일 또는 인라인 속성의 위치를 구성하는 데 사용.

@DynamicPropertySource : 메소드 Annotation이고, 동적 속성 세트에 추가하는데 사용. 동적 속성은 속성 값을 미리 알지 못하는 경우에 유용

@DirtiesContext : 클래스, 메소드 Annotation이고, 애플리케이션 컨텍스트가 더티로 표시되면 테스트 프레임 워크의 캐시에서 제거되고 닫힙니다. 
                  결과적으로 기본 Spring 컨테이너는 동일한 구성 메타 데이터를 가진 컨텍스트가 필요한 후속 테스트를 위해 다시 빌드됩니다.

@TestExecutionListeners : 클래스 Annotation이고, TestExecutionListener등록해야하는 구현 을 구성하기위한 메타 데이터를 정의.

@RecordApplicationEvents : 클래스 Annotation이고, 단일 테스트를 실행 하는 동안 게시 된 모든 애플리케이션 이벤트를 기록 하도록 Spring TestContext Framework 에 지시하는 데 사용.

@Commit : 트랜잭션 테스트 메서드에 대한 트랜잭션이 테스트 메서드가 완료된 후 커밋되어야 함을 나타냄.( == @Rollback(false) )

@Rollback : 테스트 메서드가 완료된 후 트랜잭션 테스트 메서드에 대한 트랜잭션을 롤백해야하는지 여부.(true트랜잭션이 롤백, false면 커밋)

@BeforeTransaction: 메소드가 트랜잭션이 시작되기 전에 실행되어야 함을 나타냄.

@AfterTransaction: 메소드가 트랜잭션 종료 후 실행되어야 함을 나타냄.

@Sql: 통합 테스트 중에 주어진 데이터베이스에 대해 실행될 SQL 스크립트를 구성하기 위해 테스트 클래스 또는 테스트 메소드에 Annotation 추가하는 데 사용

@Test
@Sql({"/test-schema.sql", "/test-user-data.sql"}) 
void userTest() {
    // run code that relies on the test schema and test data
}

@SqlConfig : @Sql Annotation으로 구성된 SQL 스크립트를 구문 분석하고 실행하는 방법을 결정하는 데 사용되는 메타 데이터를 정의.

@Test
@Sql(
    scripts = "/test-user-data.sql",
    config = @SqlConfig(commentPrefix = "`", separator = "@@") 
)
void userTest() {
    // run code that relies on the test data
}


@SqlMergeMode: 테스트 클래스 또는 테스트 메서드에 Annotation을 달아 메서드 수준 @Sql선언이 클래스 수준 선언과 병합 되는지 여부를 구성하는 데 사용.
 @Sql. @SqlMergeMode테스트 클래스 또는 테스트 메서드에서이 선언되지 않은 경우 OVERRIDE병합 모드가 기본적으로 사용됩니다. 
 OVERRIDE모드를 사용하면 메서드 수준 @Sql선언이 클래스 수준 선언을 효과적으로 재정의 @Sql합니다.
 
@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) 
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    void standardUserProfile() {
        // run code that relies on test data set 001
    }
}

@SqlGroup : @SqlAnnotation 을 집계하는 컨테이너 Annotation.
			여러 중첩 된 @Sql주석 을 선언 하거나 Java 8의 반복 가능한 Annotation 지원과 함께 사용할 @Sql수 있습니다

@Test
@SqlGroup({ 
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // run code that uses the test schema and test data
}


- 표준 Annotation 지원
@Autowired

@Qualifier

@Value

@Resource (javax.annotation) JSR-250이있는 경우

@ManagedBean (javax.annotation) JSR-250이있는 경우

@Inject (javax.inject) JSR-330이있는 경우

@Named (javax.inject) JSR-330이있는 경우

@PersistenceContext (javax.persistence) JPA가있는 경우

@PersistenceUnit (javax.persistence) JPA가있는 경우

@Required

@Transactional(org.springframework.transaction.annotation) 와 제한된 속성 지원


- Spring Junit5 테스트 Annotation

@SpringJUnitConfig : @ExtendWith(SpringExtension.class) JUnit5와 @ContextConfigurationSpring TestContext Framework의 합성 Annotation.
				     구성 요소 클래스가의 value속성을 사용하여 선언 될 수 있음.
					 
@SpringJUnitConfig(TestConfig.class) 
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}					 

@SpringJUnitWebConfig       @ExtendWith(SpringExtension.class), @ContextConfiguration, @WebAppConfiguration 합성 Annotation

@SpringJUnitWebConfig(TestConfig.class) 
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}

@TestConstructor : 테스트 클래스 생성자의 매개 변수가 테스트의 구성 요소에서 자동 연결되는 방식을 구성하는 데 사용.
				   @Autowired생성자에 대한 로컬 선언이 @TestConstructor및 기본 모드 보다 우선.
				   기본 테스트 생성자 자동 연결 모드 는 spring.test.constructor.autowire.modeJVM 시스템 속성을 로 설정하여 변경할 수 있음.
				   

@NestedTestConfiguration : 내부 테스트 클래스를위한 엔 클로징 클래스 계층 구조 내에서 Spring 테스트 구성 어노테이션이 처리되는 방식을 구성하는 데 사용.
							기본 포함 구성 상속 모드 는 INHERIT이지만 spring.test.enclosing.configurationJVM 시스템 속성을 로 설정하여 변경할 수 있음.
							@NestedTestConfiguration일반적으로 @NestedJUnit Jupiter의 테스트 클래스 와 함께 사용하는 경우에만 의미가 있습니다.
@EnabledIf : 테스트 클래스 또는 테스트 메서드가 활성화되었음을 알리는 데 사용되고, String과 같 거나 같으면 true (대소 문자 무시) 테스트가 활성화됩니다.

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@EnabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Enabled on Mac OS"
)
public @interface EnabledOnMac {}


@DisabledIf : 테스트 클래스 또는 테스트 메서드가 비활성화되었음을 알리는 데 사용

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@DisabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Disabled on Mac OS"
)
public @interface DisabledOnMac {}

- Meta-Annotation 지원
 대부분의 테스트 관련 주석을 메타 주석 으로 사용하여 사용자 지정 작성된 주석을 만들고 테스트 스위트에서 구성 중복을 줄일 수 있습니다.
 메타 주석은 다른 주석에 적용 할 수있는 주석


2.4 Spring TestContext 프레임 워크


Spring TestContext 프레임 워크는 사용중인 테스트 프레임워크에 관계없이 일반적인 Annotation 기반 단위,통합 테스트 지원을 제공합니다.
일반적인 테스트 인프라 외에도 Junit4(vintage), Junit5(Jupiter) 및 TestNG에 대한 명시적인 지원을 제공합니다.
Junit4와 TestNG의 경우 abstract 클래스를 제공하고, Junit4 용 Runner, Junit5 용 Rules 사용자 정의 Extension을 제공.
POJO 테스트 클래스는 abstract지원 클래스와 같은 특정 클래스 계층을 확장하는 데 필요하지 않습니다.

*TestContext 프레임 워크의 내부에 대한 개요
주요 추상화
프레임워크의 핵심은 TestContextManager 클래스와 TestContext, TestExecutionListener, SmartContextLoader 인터페이스로 구성.
TestContextManager는 각 테스트 클래스에 대해 생성되고 테스트가 진행됨에 따라 테스트 컨텍스트의 상태를 업데이트하고, 
종속성 주입, 트랜잭션 관리 등을 제공하여 실제 테스트 실행을 지시하는 TestExecutionListener 구현에 위임합니다.


TestContext: 테스트가 실행되는 컨텍스트를 캡슐화하고 해당 컨텍스트를 담당하는 테스트 인스턴스에 대한 컨텍스트 관리 및 캐싱 지원을 제공.

TestContextManager:  주요 진입 점 TestContext이며 TestExecutionListener 잘 정의 된 테스트 실행 지점에 등록 된 각 이벤트에 대한 단일 및 신호 이벤트를 관리
                    before all, before each method, test instance, after all, after each method 등을 관리

TestExecutionListener: TestContextManager에 의해 실행되는 테스트 실행에 반응하기 위해 API를 정의합니다.

@ContextConfiguration
@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})
class MyTest {
    // class body...
}

ContextLoader: ApplicationContextSpring TestContext Framework에서 관리하는 통합 테스트를위한를 로드하기 위한 전략 인터페이스입니다.
			  SmartContextLoader는 지정된 테스트 클래스에 대한 Application Context를 로드하는 역할
			                      리소스 위치, component 클래스 또는 컨텍스트 이니셜라이저를 처리하도록 선택할 수 있습니다.
 



Spring Framework 5.3.3 이후, 테스트 컨텍스트 프레임워크는 애플리케이션 컨텍스트에 게시된 애플리케이션 이벤트를 기록하기 위한 지원을 제공하여
테스트 내에서 해당 이벤트에 대해 주장을 수행할 수 있도록 한다. 
단일 테스트 실행 중에 게시된 모든 이벤트는 java.util.stream으로 처리할 수 있는 ApplicationEvents API를 통해 사용할 수 있습니다.

@SpringJUnitConfig(/* ... */)
@RecordApplicationEvents 
class OrderServiceTests {

    @Autowired
    OrderService orderService;

    @Autowired
    ApplicationEvents events; 

    @Test
    void submitOrder() {
        // Invoke method in OrderService that publishes an event
        orderService.submitOrder(new Order(/* ... */));
        // Verify that an OrderSubmitted event was published
        int numEvents = events.stream(OrderSubmitted.class).count(); 
        assertThat(numEvents).isEqualTo(1);
    }
}



테스트 실행 이벤트 
Spring Framework 5.2에 도입된 Event Publishing Test Execution Listener는 사용자 정의 Test Execution Listener를 구현하기 위한 대체 접근 방식을 제공합니다.
@BeforeTestClass - BeforeTestClassEvent        
@PrepareTestInstance - PrepareTestInstanceEvent
@BeforeTestMethod - BeforeTestMethodEvent
@BeforeTestExecution - BeforeTestExecutionEvent
@AfterTestExecution - AfterTestExecutionEvent
@AfterTestMethod - AfterTestMethodEvent
@AfterTestClass - AfterTestClassEvent

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


3.5.6. 컨텍스트 관리
테스트 인스턴스에 컨텍스트 관리 및 캐싱 지원을 제공합니다.
- 애플리케이션 컨텍스트를 주입
@SpringJUnitConfig
class MyTest {

    @Autowired 
    ApplicationContext applicationContext;

    // class body...
}

- 웹 애플리케이션 컨텍스트를 주입
@SpringJUnitWebConfig 
class MyWebAppTest {

    @Autowired 
    WebApplicationContext wac;

    // class body...
}

DependencyInjectionTestExecutionListener에서 @Autowierd 사용으로 Dependency Injection(DI)하는 것을 제공한다.
@ContextConfiguration 클래스 수준의 Annotation은 테스트 클래스가 응용 프로그램 컨텍스트 리소스 위치 또는
 구성 요소 클래스를 명시적으로 선언하지 않는 경우 구성된 ContextLoader 기본 위치 또는 기본 구성 클래스에서 
 컨텍스트를 로드하는 방법을 결정한다. 컨텍스트 리소스 위치 및 구성요소 클래스 외에도 
 애플리케이션 컨텍스트 이니셜라이저를 통해 애플리케이션 컨텍스트를 구성할 수 있다.

테스트를 위해 애플리케이션 컨텍스트를 로드하는 방법으로는 xml Resource, component class, groovy script등이 있고,
@ContextConfiguration에 해당 파일의 경로를 지정할때는 location 속성값은 생략될 수 있다. 

@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"}) 
class MyTest {
    // class body...
}

@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-config.xml"}) 
class MyTest {
    // class body...
}

만약 location값을 지정하지 않으면 TestContext 프레임워크는 기본 xml 리소스를 찾는다.
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration 
class MyTest {
    // class body...
}


component class 지정방법


@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) 
class MyTest {
    // class body...
}

component class는 다음과 같은 class를 적용할 수 있다.
- @Configuration가 Annotated된 클래스.
- @Component, @Service, @Repository 등의 stereotype Annotations가 Annotated된 클래스.
- JSR-330 호환되는 @Inject, @Named 등의 javax.inject Annotation가 Annotated된 클래스.
- @Bean 메서드를 포함하는 클래스.
- Spring Annotation을 사용하지 않고 단일 생성자의 자동 로드(automatic autowiring)기능을 활용할 수 있는 Spring component로 등록하려는 클래스.

@ContextConfiguration의 classes 값을 생략하면 TestContext 프레임워크는 기본 구성 클래스를 아래와 같은 방법으로 찾습니다.
AnnotationConfigContextLoader and AnnotationConfigWebContextLoader는 @Configuration이 명시된 구성 클래스 구현 요구 사항을 충족하는 
테스트 클래스의 모든 정적 중첩 클래스를 탐지합니다. 또한 테스트 클래스는  하나 이상의 정적 중첩 클래스를 포함할 수 있습니다.
@SpringJUnitConfig 
// ApplicationContext will be loaded from the
// static nested Config class
class OrderServiceTest {

    @Configuration
    static class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        OrderService orderService() {
            OrderService orderService = new OrderServiceImpl();
            // set properties, etc.
            return orderService;
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // test the orderService
    }

}

컨텍스트 이니셜라이저를 사용하여 테스트에 대한 애플리케이션 컨텍스트를 구성하려면 
@ContextConfiguration Annotation을 추가하고 ApplicationContextInitializer를 구현하는 클래스에 대한
참조를 포함하는 배열로 이니셜라이저 속성을 구성하세요.
정의된 컨텍스트 이니셜라이저를 사용하여 테스트에 로드된 ConfigurableApplicationContext를 초기화 합니다.
지원되는 애플리케이션 컨텍스트 유형은 SmartContextLoader에서 생성한 애플리케이션 컨텍스트 유형과 호환되어야 하고,
초기화 순서는 @Order 또는 @Priority가 Annotated되는 것에 따라 달라집니다.

@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class) 
class MyTest {
    // class body...
}


*환경 프로파일을 사용한 컨텍스트 구성
통합 테스트는 다양한 테스트 시나리오에 대한 특정 bean definition profiles를 활성화하도록 구성할 수 있습니다.
@ActiveProfiles Annotation을 테스트 클래스에 Annotated하고 
테스트를 위한 Application Context를 로드할 때 활성화되어야 하는 프로필 목록을 제공합니다.

SmartContextLoader SPI를 구현하는데 @ActiveProfiles를 사용할 수 있지만
@ActiveProfiles는 이전 ContextLoader SPI를 구현하는 데 지원되지 않습니다.

사용예


@Configuration
@Profile("dev")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}

@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}

@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}

@Configuration
public class TransferServiceConfig {

    @Autowired DataSource dataSource;

    @Bean
    public TransferService transferService() {
        return new DefaultTransferService(accountRepository(), feePolicy());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public FeePolicy feePolicy() {
        return new ZeroFeePolicy();
    }
}

@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}

TransferServiceTest 클래스에 @ActiveProfiles("dev")를 Annotated하면 Spring Test Context Framework에
활성 프로파일이 dev로 설정된 ApplicationContext를 로드하도록 지시하면 Profile이 dev로 Annotated된
클래스의 DataSource로 연결 됩니다. 이것은 통합 테스트를 할 때 유용하게 사용될 수 있습니다.
ActiveProfiles된 프로파일이 없는 경우 DefaultDataConfig DataSource로 연결 됩니다.
@ActiveProfiles 주석의 중복된 선언을 방지하기 위해 기본 클래스에 한 번 @ActiveProfiles를 선언할 수 있으며 
하위 클래스는 자동으로 기본 클래스로부터 @ActiveProfiles 구성을 상속합니다.

@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}

// "dev" profile inherited from superclass
class TransferServiceTest extends AbstractIntegrationTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}


@ActiveProfiles의 inheritProfiles 속성값은 활성 프로필의 상속을 비활성화하는 데 사용할 수 있습니다.

// "dev" profile overridden with "production"
@ActiveProfiles(profiles = "production", inheritProfiles = false)
class ProductionTransferServiceTest extends AbstractIntegrationTest {
    // test body
}


또한  Active profiles를 
현재 운영체제 종류, 통합 빌드 서버에서 테스트가 실행 중인지, 특정 환경 변수에 따라서 달라져야 한다던지의 등의
특정 조건에 따라 선택해야될 때는 프로그래밍 방식으로 이를 해결해야 합니다. 
ActiveProfilesResolver를 implements한 클래스를 구현하고 @ActiveProfiles의 resolver 속성 값에 할당 합니다.
(servlet 4.0부터 지원됩니다.)

// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver.class,
        inheritProfiles = false)
class TransferServiceTest extends AbstractIntegrationTest {
    // test body
}

public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {

    @Override
    public String[] resolve(Class<?> testClass) {
        String profile = ...;
        // determine the value of profile based on the operating system
        return new String[] {profile};
    }
}



*테스트 속성 소스를 사용한 컨텍스트 구성
@TestPropertySource을 Annotated하여 테스트 속성 파일 또는 인라인 속성에 대한 리소스 위치를 선언할 수 있습니다. 
이러한 테스트 속성 소스는 통합 테스트를 위해 로드된 Application Context에 대한 환경의 속성 소스 집합에 추가됩니다.
SmartContextLoader SPI의 모든 구현과 함께 @TestPropertySource를 사용할 수 있지만 
@TestPropertySource는 이전 ContextLoader SPI의 구현에서는 지원되지 않습니다.

@TestPropertySource의 locations 속성 값으로 지정된 경로는 테스트 클래스가 정의된 패키지에 상대적인 클래스 경로 리소스로 처리됩니다.
절대 경로를 설정(예: /org/example/test.properties)로 지정하거나 classpath:/com/example/test.properties 형태로 지정할 수 있습니다.
하지만 리소스 위치 와일드카드(예: */.properties)는 허용되지 않습니다.

@ContextConfiguration
@TestPropertySource("/test.properties") 
class MyIntegrationTests {
    // class body...
}

@TestPropertySource의 속성값은 키-값 쌍 형식으로 인라인 속성을 구성됩니다. (혼용 사용 가능)
key=value
key:value
key value

@ContextConfiguration
@TestPropertySource(properties = {"timezone = GMT", "port: 4242"}) 
class MyIntegrationTests {
    // class body...
}

Spring Framework 5.2부터는 단일 테스트 클래스 내에 여러개의 @TestPropertySource를 Annotated할 수 있으며,
각 @TestPropertySource은 이전 @TestPropertySource보다 우선시 됩니다. 
또한 @TestPropertySource는 메타 주석으로도 사용 가능합니다.

@TestPropertySource의 속성값이 명시되지 않은 경우 기본 경로의 속성 파일을 찾으려고 합니다.
예를들어 com.example.MyTest에서 Annotated된 경우 classpath:com/example/MyTest.properties파일을 찾습니다.
만약 기본값을 검색할 수 없는 경우 InvaluateStateException이 발생합니다.

테스트 속성은 @PropertySource를 사용하거나 프로그래밍 방식으로 응용 프로그램에 의해 선언적으로 추가된 운영 체제 환경, 
Java 시스템 속성 또는 속성 소스에서 정의된 것보다 높은 우선 순위를 가집니다. 
또한 @TestPropertySource 속성 내에 지정한 속성 파일보다 인라인 속성값의 우선순위가 높습니다.
아래와 같은 예제에서 test.properties에 port가 8080으로 정의 되어 있고, 인라인 속성의 port가 4242이면 
port는 4242로 재정의 됩니다.

@ContextConfiguration
@TestPropertySource(
    locations = "/test.properties",
    properties = {"timezone = GMT", "port: 4242"}
)
class MyIntegrationTests {
    // class body...
}

상속 구조에서는 기본적으로 부모 클래스에 Annotated된 @TestPropertySource 설정을 상속 받고,
하위 클래스에 별도로 @TestPropertySource를 구성할 경우 하위 클래스는 두 개의 설정 모두 적용됩니다.
만약 부모 클래스의 설정값을 사용하지 않을려면 @TestPropertySource 속성 값 중 inheritLocations 또는 
inheritProperties을 false로 설정하면 됩니다.

@TestPropertySource("base.properties")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}


*동적 속성 소스를 사용한 컨텍스트 구성
Spring Framework 5.2.5를 기준으로 테스트 컨텍스트 프레임워크는 @DynamicPropertySource Annotation을 통해 동적 속성을 지원합니다.
통합 테스트를 위해 로드된 Application Context에 대한 환경의 속성 소스 집합에 동적 값을 가진 속성을 추가해야 하는 통합 테스트에 사용할 수 있습니다.
이 기능은 라이프사이클이 테스트의 애플리케이션 컨텍스트 외부에 유지되는 모든 형태의 외부 리소스에도 사용할 수 있습니다.

@DynamicPropertySource는 단일 DynamicProperty Registry 인수를 허용하는 정적 메서드에 적용되어야 하며 @TestPropertySource나
프로그래밍 방식으로 애플리케이션에 로드된 속성보다 우선 순위가 높습니다.


스프링 응용 프로그램 컨텍스트 외부에서 Redis 컨테이너를 관리하기 위해 테스트 컨테이너 프로젝트를 사용하는
다음 예제에서 볼 수 있듯이 값을 제공하는데 사용됩니다. 
관리되는 Redis 컨테이너의 IP 주소와 포트는 Redis를 통해 테스트의 Application Context 내의 구성 요소에 사용할 수 있습니다.

@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    @Container
    static RedisContainer redis = new RedisContainer();

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add("redis.host", redis::getContainerIpAddress);
        registry.add("redis.port", redis::getMappedPort);
    }

    // tests ...

}


Loading a WebApplicationContext (웹 애플리케이션 컨텍스트 로드)

해당 테스트 클래스에 @WebAppConfiguration를 Annotated하여 WebApplicationContext를 로드할 수 있습니다.
@WebAppConfiguration이 Annotated되면 WAC(Web Application Context)를 로드해야 한다고 
TCF(Test Context Framework)에 지시하고 TCF는 백그라운드에서 MockServlet 컨텍스트를 만들어 테스트 WAC에 제공합니다.
기본적으로 MockServletContext의 기본 리소스 경로는 src/main/webapp으로 설정됩니다.
웹 응용 프로그램의 디렉터리 구조를 잘 알고 있는 경우 src/main/webapp이 WAR 루트의 기본 위치임을 알 수 있습니다.
이 기본값을 재정의해야 하는 경우 @WebAppConfiguration 주석("src/test/webapp")에 대한 대체 경로를 제공할 수 있습니다.

WebApplicationContext를 사용하여 테스트할 때 @ContextConfiguration을 사용하여 
XML 구성 파일, Groovy 스크립트 또는 @Configuration 클래스를 자유롭게 선언할 수 있습니다. 
또한 @ActiveProfiles, @Test ExecutionListener, @Sql, @Rollback 등과 같은 다른 모든 테스트 주석을 자유롭게 사용할 수 있습니다.

@ExtendWith(SpringExtension.class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}


@WebAppConfiguration 리소스 경로는 파일 시스템 기반이고 @ContextConfiguration 리소스 위치는 classpath 기반입니다.

@ExtendWith(SpringExtension.class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}

스프링 리소스 접두사를 지정하여 두 Annotation에 대한 기본 리소스를 재정의할 수 있습니다.

@ExtendWith(SpringExtension.class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}

* WebMock 사용
포괄적인 웹 테스트 지원을 제공하기 위해 테스트 컨텍스트 프레임워크에는 
기본적으로 사용 가능한 ServletTestExecutionListener가 있습니다.
 
 WebApplicationContext에 대해 테스트를 할 때, TestExecutionListener는 각 테스트 전에 
 Spring Web의 RequestContextHolder를 사용하여 기본 스레드를 로컬 상태로 설정하고
 @WebAppConfiguration로 구성된 기본 리소스 경로를 기반으로
 MockHttpServletRequest, MockHttpServletResponse, ServletWebRequest를 생성합니다.
 ServletTestExecutionListener은 MockHttpServletResponse와 ServletWebRequest가 테스트 객체에
 주입될수 있도록 하고 테스트가 완료되면 로컬상태의 스레드를 clean합니다.

WebApplicationContext를 로드한 후에
테스트 픽스처(fixtures)를 설정하거나 Web Component를 invoking한 다음 단정문(assertions)을 실행할 때는 
web mock와 상호 작용해야 됩니다. 
WebApplication Context와 MockServlet Context는 모두 테스트 제품군에 캐시되는 반면
다른 mock들은 테스트 메서드 별로 ServletTestExecutionListener에 의해 관리 됩니다.

픽스처: 테스트를 수행하는 데 필요한 정보나 오브젝트

@SpringJUnitWebConfig
class WacTests {

    @Autowired
    WebApplicationContext wac; // cached

    @Autowired
    MockServletContext servletContext; // cached

    @Autowired
    MockHttpSession session;

    @Autowired
    MockHttpServletRequest request;

    @Autowired
    MockHttpServletResponse response;

    @Autowired
    ServletWebRequest webRequest;

    //...
}

TestContext 프레임워크는 다음 구성 매개 변수를 사용하여 컨텍스트 캐시 키를 구축합니다.

locations (from @ContextConfiguration)

classes (from @ContextConfiguration)

contextInitializerClasses (from @ContextConfiguration)

contextCustomizers (from ContextCustomizerFactory) – 
(@DynamicPropertySource 뿐만 아니라 Spring Boot의 테스트 지원을 위한 @MockBean,  @SpyBean도 포함됩니다.)

contextLoader (from @ContextConfiguration)

parent (from @ContextHierarchy)

activeProfiles (from @ActiveProfiles)

propertySourceLocations (from @TestPropertySource)

propertySourceProperties (from @TestPropertySource)

resourceBasePath (from @WebAppConfiguration)

예를들어 TestClassA와 TestClassB가 @ContextConfiguration({{"app-config.xml", "test-config.xml"}})를 동일하게 
annotated 한다면 두 테스트 클래스 간  컨텍스트 캐시는 공유 됩니다.
단 다른 ContextLoader, 다른 활성 프로필, 다른 컨텍스트 이니셜라이저, 
다른 테스트 속성 소스 또는 다른 상위 컨텍스트를 정의하면 공유되지 않습니다.

또한 스프링 테스트 컨텍스트 프레임워크는 응용 프로그램 컨텍스트를 정적 캐시에 저장합니다. 
테스트가 별도의 프로세스에서 실행되는 경우 각 테스트 실행 간에 정적 캐시가 삭제되어 캐싱 메커니즘을 효과적으로 사용할 수 없게 됩니다.
따라서 캐싱 메커니즘의 이점을 얻으려면 모든 테스트가 동일한 프로세스 또는 테스트 제품군 내에서 실행되어야 합니다. 
이것은 IDE 내의 그룹으로 모든 테스트를 실행함으로써 달성될 수 있습니다. 
마찬가지로, Ant, Maven 또는 Gradle과 같은 빌드 프레임워크로 테스트를 실행할 때
빌드 프레임워크가 테스트 사이에 포크를 갖지 않도록 하는 것이 중요합니다.

컨텍스트 캐시의 크기는 기본 최대 크기 32로 제한됩니다. 
최대 크기에 도달할 때마다 가장 최근에 사용된(LRU) 제거 정책이 오래된 컨텍스트를 제거하고 닫는 데 사용됩니다.
spring.test.context.cache.maxSize라는 JVM 시스템 속성을 설정하여 명령줄 또는 빌드 스크립트에서 최대 크기를 구성할 수 있습니다.
대안으로 Spring Properties 메커니즘을 통해 동일한 속성을 설정할 수 있습니다.


얼마나 많은 컨텍스트를 로드하고 캐시했는지 정확하게 알기 위해 기본 컨텍스트 캐시에 대한 통계를 보려면
org.springframework.test.context.cache 로깅 범주에 대한 로그 수준을 DEBUG로 설정할 수 있습니다.

애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는 것이 원칙이며 만약 특정 테스트 클래스에서
애플리케이션 컨텍스트를 변경해야될 경우 @DirtiesContext를 Annotated하면 이 클래스에 대해서는
애플리케이션 컨텍스트에 공유를 허용하지 않는다. 이는 테스트 중에 변경한 컨텍스트가 다른 테스트에 영향을 주지 않기 위해서다.

Spring의 Annotation 기반 Injection 지원과의 일관성을 위해 Spring의 @Autowire 또는 필드 및 세터 주입에 
JSR-330의 @Inject Annotation을 사용할 수도 있습니다.
JUNIT 목성 이외의 테스트 프레임워크의 경우 테스트 컨텍스트 프레임워크는 테스트 클래스의 인스턴스화에 참여하지 않습니다. 
따라서 생성자를 위해 @Autowire 또는 @Inject를 사용하는 것은 테스트 클래스에 영향을 미치지 않습니다.

Production 코드에서는 필드 주입이 억제되지만 테스트 코드에서는 필드 주입이 실제로 매우 자연스럽습니다. 
그 이유는 테스트 클래스를 직접 인스턴스화하지 않기 때문입니다. 
따라서 테스트 클래스에서 공개 생성자 또는 설정자 메서드를 호출할 필요가 없습니다.

@Autowierd는 빈의 Type 별로 AutoWiring하기 때문에 동일한 Type의 유형이 여러개가 있는 경우 @Qualifier를 사용해야 합니다.
@Inject를 @Named와 함께 사용하도록 선택할 수도 있습니다.
테스트 클래스가 ApplicationContext.getBean("titleRepository", TitleRepository.class)에 대한 호출을 사용하여 명시적 룩업을 수행할 수 있습니다.

JUnit5에서 @Autowired로 필드 Injection 예

@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    HibernateTitleRepository titleRepository;

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}


setter Injection 예
@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    HibernateTitleRepository titleRepository;

    @Autowired
    void setTitleRepository(HibernateTitleRepository titleRepository) {
        this.titleRepository = titleRepository;
    }

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}

Injection시 동일 Type의 빈이 있는 경우 @Qualifier Annotation을 사용
@Autowired
@Override
public void setDataSource(@Qualifier("myDataSource") DataSource dataSource) {
    super.setDataSource(dataSource);
}


*Request-Scoped와 Session-Scoped 빈들을 테스트
step-1. @WebAppConfiguration을 테스트 클래스에 Annotated해서 Web Appication Context가 로드 되는지 확인합니다.
step-2. 테스트 객체 또는 테스트 픽스처(fixture)에 모의 요청(mock request) 또는 세션을 injection 합니다.
step-3. 구성된 Web Application Context에서 DI된 Component를 호출합니다.
step-4.  mocks에 대해 단정문(assertions)를 실행합니다.

테스트에서는 테스트 컨텍스트 프레임워크에서 관리하는 모크를 통해 
사용자 이름과 암호를 검색하는 SpEL 식을 사용하여 로그인 작업을 인스턴스화하는 요청 매개 변수를 구성합니다. 
Request-scoped bean configuration
<beans>
    <bean id="userService" class="com.example.SimpleUserService"
            c:loginAction-ref="loginAction"/>
    <bean id="loginAction" class="com.example.LoginAction"
            c:username="#{request.getParameter('user')}"
            c:password="#{request.getParameter('pswd')}"
            scope="request">
        <aop:scoped-proxy/>
    </bean>
</beans>

RequestScopedBeanTests에서는 UserService와 MockHttpServletRequest를 모두 테스트 인스턴스에 Injection(주입)합니다.
requestScope() 테스트 메서드 내에서 MockHttpServletRequest에서 제공되는 request parameters로 테스트 픽스처(fixture)를 
설정합니다.

userService에서 loginUser() 메서드가 호출되면 user service가
현재 MockHttpServletRequest의 request-scoped loginAction에 액세스 할 수 있습니다.
그런 다음 사용자 이름과 암호 입력을 기반으로 결과에 대해 단정문(assertions)을 수행할 수 있습니다.

@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpServletRequest request;

    @Test
    void requestScope() {
        request.setParameter("user", "enigma");
        request.setParameter("pswd", "$pr!ng");

        LoginResults results = userService.loginUser();
        // assert results
    }
}


<beans>
    <bean id="userService" class="com.example.SimpleUserService"
            c:userPreferences-ref="userPreferences" />

    <bean id="userPreferences" class="com.example.UserPreferences"
            c:theme="#{session.getAttribute('theme')}"
            scope="session">
        <aop:scoped-proxy/>
    </bean>
</beans>

@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpSession session;

    @Test
    void sessionScope() throws Exception {
        session.setAttribute("theme", "blue");

        Results results = userService.processUserPreferences();
        // assert results
    }
}


*트랜잭션 관리
트랜잭션을 지원하려면 @ContextConfiguration semantics이 로드된 
ApplicationContext에서 PlatformTransactionManager를 설정해야 합니다.
또한 테스트 클래스에 @Transactional를 Annotated 해야 합니다.

테스트 관리 트랜잭션은 TransactionalTestExecutionListener를 사용하여 관리되거나 
TestTransaction을 사용하여 프로그래밍 방식으로 관리되는 트랜잭션입니다.

트랜잭션을 Spring 관리 트랜잭션(테스트용으로 로드된 Application Context 내에서 Spring이 직접 관리하는 트랜잭션) 
또는 애플리케이션 관리 트랜잭션(테스트에서 호출되는 애플리케이션 코드 내에서 프로그래밍 방식으로 관리되는 트랜잭션)과
혼동해서는 안 됩니다.

스프링 관리 트랜잭션과 애플리케이션 관리 트랜잭션은 일반적으로 테스트 관리 트랜잭션에 참여합니다. 
그러나 스프링 관리 또는 애플리케이션 관리 트랜잭션이 필수 또는 지원 이외의 다른 전파 유형으로 구성된 경우에는 주의해야 합니다.

스프링 테스트는 현재 테스트 메서드가 호출되기전에 현재 쓰래드(java.lang.ThreadLocal 변수)에 트랜잭션 상태를 바인딩 합니다.
시간 제한을 지원하기 위해 테스트 프레임워크가 새 스레드에서 현재 테스트 방법을 호출하는 경우 
현재 테스트 방법 내에서 수행되는 작업은 테스트 관리 트랜잭션 내에서 호출되지 않습니다. 
따라서 그러한 조치의 결과는 테스트 관리 트랜잭션으로 롤백되지 않습니다. 
반대로 테스트 관리 트랜잭션이 Spring에 의해 적절하게 롤백되더라도 이러한 작업은 관계형 데이터베이스와
같은 영구 저장소로 커밋됩니다.
다음과 같은 상황에 발생할 수 있고 이외에도 발생할 수 있습니다.
JUnit 4’s @Test(timeout = …​) support and TimeOut rule
JUnit Jupiter’s assertTimeoutPreemptively(…​) methods in the org.junit.jupiter.api.Assertions class
TestNG’s @Test(timeOut = …​) support

@Transaction을 사용하여 테스트 방법에 주석을 달면 기본적으로 테스트가 완료된 후 자동으로 롤백되는 트랜잭션 내에서 테스트가 실행됩니다.
JUnit5(Jupiter)의 테스트 라이프사이클 메서드인 @BeforeAll, @AfterAll 등으로 Annotated한 메서드들은 
테스트 수명 주기 방법에서는 @Transaction이 지원되지 않습니다. 
더욱이, @Transaction으로 주석이 달렸지만 전파 특성이 NOT_SUSPEED 또는 NEVER로 설정된 테스트는 트랜잭션 내에서 실행되지 않습니다.

@Transactional attribute support Attribute

value and transactionManager: yes

propagation: only Propagation.NOT_SUPPORTED and Propagation.NEVER are supported

isolation: no

timeout: no

readOnly: no

rollbackFor and rollbackForClassName: no, use TestTransaction.flagForRollback() instead 

noRollbackFor and noRollbackForClassName: no, use TestTransaction.flagForCommit() instead


----------------
@SpringJUnitConfig(TestConfig.class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    HibernateUserRepository repository;

    @Autowired
    SessionFactory sessionFactory;

    JdbcTemplate jdbcTemplate;

    @Autowired
    void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    void createUser() {
        // track initial state in test database:
        final int count = countRowsInTable("user");

        User user = new User(...);
        repository.save(user);

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush();
        assertNumUsers(count + 1);
    }

    private int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    private void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}
-----------------------
트랜잭션 롤백 및 커밋 동작
기본적으로 테스트 트랜잭션은 테스트 완료 후 자동으로 롤백되지만 트랜잭션 커밋 및 롤백 동작은 @Commit 및 @Rollback 주석을 통해 선언적으로 구성할 수 있습니다. 
TransactionalTestExecutionListener는 트랜잭션 동작을 확인하기 위한 @BeforeTransaction 및 @AfterTransaction Annotation을 지원합니다.
테스트의 ApplicationContext 내에 PlatformTransactionManager 인스턴스가 여러 개 있는 경우 @Transaction(TransactionManager = "myTxMgr")을 사용하여
한정자를 선언하거나, @Configuration 클래스에서 TransactionManagementConfiger를 구현할 수 있습니다.

@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    void verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    void setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    void modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    void tearDownWithinTransaction() {
        // run "tear down" logic within the transaction
    }

    @AfterTransaction
    void verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}


ORM 코드를 테스트할 때 세션 또는 JPA 영속성 컨텍스트의 상태를 조작하는 코드를 테스트할때 해당 메서드 내에서 기본 작업 단위를 flush해야 합니다.
기본작업을 flush하지 않으면 false positives가 발생할 수 있습니다.
- hibernate 방법
// ...

@Autowired
SessionFactory sessionFactory;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInHibernateSession();
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithSessionFlush() {
    updateEntityInHibernateSession();
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush();
}

// ...


- 다음은 JPA에 대한 방법 
// ...

@PersistenceContext
EntityManager entityManager;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInJpaPersistenceContext();
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext();
    // Manual flush is required to avoid false positive in test
    entityManager.flush();
}

// ...


SQL 스크립트 실행
관계형 데이터베이스에 대한 통합 테스트를 작성할 때 SQL 스크립트를 실행하여 데이터베이스 스키마를 수정하거나 테스트 데이터를 테이블에 삽입하는 것이 종종 유용합니다. 
Spring-jdbc 모듈은 Spring Application Context가 로드될 때 SQL 스크립트를 실행하여 내장형 또는 기존 데이터베이스를 초기화할 수 있도록 지원합니다. 
SQL 스크립트를 실행하는 데 다음과 같은 옵션을 제공합니다.

org.springframework.jdbc.datasource.init.ScriptUtils
SQL 스크립트 작업을 위한 정적 유틸리티 메소드의 모음을 제공하며 주로 프레임워크 내에서 내부 용도로 사용됩니다. 
그러나 SQL 스크립트 구문 분석 및 실행 방법을 완전히 제어해야 하는 경우 ScriptUtils는 나중에 설명할 다른 대안보다 사용자의 요구에 더 적합할 수 있습니다.

org.springframework.jdbc.datasource.init.ResourceDatabasePopulator
외부 리소스에 정의된 SQL 스크립트를 사용하여 데이터베이스를 프로그래밍 방식으로 채우고 초기화하거나 정리하기 위한 객체 기반 API를 제공합니다. 
ResourceDatabasePopulator는 스크립트를 구문 분석하고 실행할 때 사용되는 문자 인코딩, 문장 구분 기호, 주석 구분 기호 및 오류 처리 플래그를 구성하기 위한 옵션을 제공합니다.

org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests
org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests


@Test
void databaseTest() {
    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
    populator.addScripts(
            new ClassPathResource("test-schema.sql"),
            new ClassPathResource("test-data.sql"));
    populator.setSeparator("@@");
    populator.execute(this.dataSource);
    // run code that uses the test schema and data
}


앞서 언급한 SQL 스크립트를 프로그래밍 방식으로 실행하기 위한 메커니즘 외에도 
Spring TestContext Framework에서 SQL 스크립트를 선언적으로 구성할 수 있습니다. 
특히, 개별 SQL 문을 구성하기 위해 테스트 클래스 또는 테스트 메서드에 @Sql 주석을 선언하거나 
통합 테스트 메서드 이전 또는 이후에 지정된 데이터베이스에 대해 실행해야 하는 SQL 스크립트에 대한 리소스 경로를 구성할 수 있습니다.
메서드 수준 @Sql 선언은 기본적으로 클래스 수준 선언을 재정의합니다. 
그러나 Spring Framework 5.2부터는 @SqlMergeMode를 통해 테스트 클래스 또는 테스트 방법별로 이 동작을 구성할 수 있습니다. 

@Sql Annotation의 Attribute value는 sql파일의 path이며 path는 절대경로(/org/example/schema.sql)이거나
path 접두사(classpath:, file:, http:)로 구성된 URL일 수 있습니다. (기본 경로는 classpath:com/example/MyTest.sql 형식이다.)

@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    void emptySchemaTest() {
        // run code that uses the test schema without any test data
    }

    @Test
    @Sql({"/test-schema.sql", "/test-user-data.sql"})
    void userTest() {
        // run code that uses the test schema and test data
    }
}

Java 8에서 @Sql을 반복 가능한 주석으로 사용하는 방법

@Test
@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))
@Sql("/test-user-data.sql")
void userTest() {
    // run code that uses the test schema and test data
}

Java 8 이상에서는 @SqlGroup을 사용할 수 있지만 Kotlin과 같은 다른 JVM 언어와의 호환성을 위해 @SqlGroup을 사용해야 할 수도 있습니다.
@Test
@SqlGroup({
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // run code that uses the test schema and test data
}


기본적으로 SQL 스크립트는 해당 테스트 메서드보다 먼저 실행됩니다. 
만약 테스트 방법 이후에 특정 스크립트 집합을 실행해야 하는 경우
@Test
@Sql(
    scripts = "create-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED)
)
@Sql(
    scripts = "delete-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED),
    executionPhase = AFTER_TEST_METHOD
)
void userTest() {
    // run code that needs the test data to be committed
    // to the database outside of the test's transaction
}

ISOLATED와 AFTER_TEST_METHOD는 각각 Sql.TransactionMode와 Sql.ExecutionPhase에서 정적 imported 된다.


@SqlConfig Annotation을 사용하여 스크립트 구문 분석 및 오류 처리를 구성할 수 있습니다. 
통합 테스트 클래스에 annotated되면 @SqlConfig는 테스트 클래스 계층 구조 내의 모든 SQL 스크립트에 대한 전역 구성 역할을 합니다.

@Sql에 대한 트랜잭션 관리
기본적으로 SqlScriptsTest ExecutionListener는 @Sql을 사용하여 구성된 스크립트에 대해 원하는 트랜잭션 의미를 추론합니다. 
SQL 스크립트는 트랜잭션 없이 기존 Spring 관리 트랜잭션(A) 내에서 실행되거나 
격리된 트랜잭션 내에서 @SqlConfig의 설정된 transactionMode 속성 값과 
테스트의 ApplicationContext에서 PlatformTransactionManager의 존재 여부에 따라 달라집니다.


SQLScripts에서 알고리즘을 사용하는 경우 DataSource 및 PlatformTransactionManager를 감지하고 트랜잭션 의미론을 유추하기 위해 테스트 ExecutionListener를 테스트합니다. 
@SqlConfig의 transactionMode 속성을 설정하여 트랜잭션 전파 동작을 제어할 수 있습니다(예: 분리된 트랜잭션에서 스크립트를 실행해야 하는지 여부)

@SpringJUnitConfig(TestDatabaseConfig.class)
@Transactional
class TransactionalSqlScriptsTests {

    final JdbcTemplate jdbcTemplate;

    @Autowired
    TransactionalSqlScriptsTests(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    @Sql("/test-data.sql")
    void usersTest() {
        // verify state in test database:
        assertNumUsers(2);
        // run code that uses the test data...
    }

    int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    void assertNumUsers(int expected) {
        assertEquals(expected, countRowsInTable("user"),
            "Number of rows in the [user] table.");
    }
}


@SqlMergeMode와 구성 병합 및 재정의
Spring Framework 5.2에서는 메서드 수준 @Sql 선언과 클래스 수준 선언을 병합할 수 있습니다. 
예를 들어, 이를 통해 데이터베이스 스키마 또는 일부 공통 테스트 데이터에 대한 구성을
테스트 클래스당 한 번씩 제공한 다음 테스트 방법당 사용 사례별 테스트 데이터를 추가로 제공할 수 있습니다. 
@Sql 병합을 사용하려면 @SqlMergeMode(MERGE)를 사용하여 테스트 클래스 또는 테스트 메서드에 Annotation을 추가하십시오. 
특정 테스트 방법(또는 특정 테스트 하위 클래스)에 대한 병합을 사용하지 않도록 설정하려면 
@SqlMergeMode(OVERRIDE)를 통해 기본 모드로 다시 전환할 수 있습니다. 


병렬 테스트 실행
Spring Framework 5.0은 Spring Test Context Framework를 사용할 때 단일 JVM 내에서 병렬로 테스트를 실행하기 위한 기본 지원을 도입하였다.
병렬 테스트 실행을 설정하는 방법에 대한 자세한 내용은 테스트 프레임워크, 빌드 도구 또는 IDE 설명서를 참조하십시오.

다음과 같은 경우 테스트를 병렬로 실행하지 마십시오.

-Spring Framework의 @DirtiesContext 지원을 사용.

-Spring Boot의 @MockBean 또는 @SpyBean 지원을 사용.

-JUNit 4의 @FixMethodOrder 지원 또는 테스트 방법이 특정 순서로 실행되도록 설계된 모든 테스트 프레임워크 기능을 사용합니다. 
그러나 전체 테스트 클래스가 병렬로 실행되는 경우에는 적용되지 않습니다.

-데이터베이스, 메시지 브로커, 파일 시스템 등과 같은 공유 서비스 또는 시스템의 상태를 변경합니다. 
이는 임베디드 시스템과 외부 시스템 모두에 적용됩니다.



Spring JUnit 4 Runner
@RunWith(SpringRunner.class) 변형으로 개발자는 표준 JUNit 4 기반 유닛 및 통합 테스트를 구현할 수 있으며, 
애플리케이션 컨텍스트 로딩, 테스트 인스턴스의 종속성 주입, 트랜잭션 테스트 방법 실행 및 같은 테스트 컨텍스트 프레임워크의 이점을 동시에 얻을 수 있다

@RunWith(SpringRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

    @Test
    public void testMethod() {
        // test logic...
    }
}

Spring JUnit 4 Rules
JUNIT 테스트 규칙
org.springframework.test.context.junit4.rules 패키지에 SpringClassRule, SpringMethodRule를 제공함.

// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
public class IntegrationTest {

    @ClassRule
    public static final SpringClassRule springClassRule = new SpringClassRule();

    @Rule
    public final SpringMethodRule springMethodRule = new SpringMethodRule();

    @Test
    public void testMethod() {
        // test logic...
    }
}


* SpringExtension for JUnit Jupiter
@ExtendWith(SpringExtension.class)로 테스트 클래스에 주석을 달면 표준 
JUnit5 기반 장치 및 통합 테스트를 구현하고 애플리케이션 컨텍스트 로드 지원, 테스트 인스턴스의 종속성 주입, 
트랜잭션 테스트 방법 실행 등과 같은 테스트 컨텍스트 프레임워크의 이점을 동시에 얻을 수 있습니다.
JUnit 4 and TestNG도 지원함.

// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension.class)
// Instructs Spring to load an ApplicationContext from TestConfig.class
@ContextConfiguration(classes = TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // test logic...
    }
}

JUnit5의 Annotation들은 메타 어노테이션으로 사용할 수 있고, 
스프링은 ApplicationContext와 JUnit5 테스트를 심플하게 구성을 하는 @SpringJUnitConfig과 @SpringJUnitWebConfig를 제공합니다.

// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // test logic...
    }
}


// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig.class
@SpringJUnitWebConfig(TestWebConfig.class)
class SimpleWebTests {

    @Test
    void testMethod() {
        // test logic...
    }
}

SpringExtension은 Junit5에서 Parameter Resolver 확장 API를 구현하여 
Spring이 테스트 생성자, 테스트 방법 및 테스트 라이프사이클 콜백 방법에 대한 종속성 주입을 제공할 수 있도록 한다.
@BeforeAll, @AfterAll, @BeforeEach, @Test, @Repeated가 Annotated된 테스트 생성자 및 메서드에 테스트의 
ApplicationContext로부터 종속성을 주입할 수 있습니다.

테스트 클래스에 대한 생성자의 특정 매개변수가 Application Context 유형(또는 그 하위 유형)이거나 
@Autowire, @Qualifier 또는 @Value로 주석 또는 메타 주석이 달린 경우, 
스프링은 해당 매개변수에 대한 값을 테스트의 Application Context 컨텍스트에서 해당 빈 또는 값으로 주입합니다.

스프링은 또한 생성자가 자동 바람직하다고 간주되는 경우 테스트 클래스 생성자에 대한 모든 인수를 Auto-Wiring 하도록 구성할 수 있습니다.

@TestConstructor(테스트 생성기)는 autowireMode 속성을 ALL로 설정한 상태로 테스트 클래스에 존재하거나 메타 존재합니다.
기본 테스트 생성자의 autowire모드가 ALL로 변경되었습니다.

테스트 클래스의 생성자 Injection에서 @TestInstance(PER_CLASS)를 사용하면 안됩니다.
만약 @DirtiesContext를 사용하면 ApplicationContext의 before 또는 after 테스트 메서드들이 종료됩니다.

@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    @Autowired
    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}

@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}

@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @Test
    void deleteOrder(@Autowired OrderService orderService) {
        // use orderService from the test's ApplicationContext
    }
}

@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    void placeOrderRepeatedly(RepetitionInfo repetitionInfo,
            @Autowired OrderService orderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}

@SpringJUnitConfig(TestConfig.class)
class GreetingServiceTests {

    @Nested
    @ActiveProfiles("lang_en")
    class EnglishGreetings {

        @Test
        void hello(@Autowired GreetingService service) {
            assertThat(service.greetWorld()).isEqualTo("Hello World");
        }
    }

    @Nested
    @ActiveProfiles("lang_de")
    class GermanGreetings {

        @Test
        void hello(@Autowired GreetingService service) {
            assertThat(service.greetWorld()).isEqualTo("Hallo Welt");
        }
    }
}


*WebTestClient

WebTest Client는 서버 응용 프로그램을 테스트하기 위해 설계된 HTTP 클라이언트입니다.
종단간 HTTP 테스트를 할 수 있고 모의 서버 요청 및 응답 객체를 통해 실행 중인 서버 없이 
Spring MVC 및 Spring WebFlux 응용 프로그램을 테스트할 수 있습니다.

setup
바인딩할 서버 설정을 선택해야 합니다. 
이것은 여러 모의 서버 설정 중 하나이거나 실시간 서버에 대한 연결일 수 있습니다.

컨트롤러에 바인딩
이 설정을 사용하면 실행 중인 서버 없이 모의 요청 및 응답 개체를 통해 특정 컨트롤러를 테스트할 수 있습니다.

WebFlux 애플리케이션의 경우 WebFlux Java 구성과 동일한 인프라를 로드하고, 
지정된 컨트롤러를 등록하고, 요청을 처리할 WebHandler 체인을 생성하는 다음을 사용합니다.
WebTestClient client =
        WebTestClient.bindToController(new TestController()).build();
		
Spring MVC의 경우 WebMvc Java 구성과 동일한 인프라를 로드하고, 
지정된 컨트롤러를 등록하고, 요청을 처리하기 위해 MockMvc 인스턴스를 생성하는 독립 실행형MockMvcBuilder로 위임하는 다음을 사용합니다.

WebTestClient client =
        MockMvcWebTestClient.bindToController(new TestController()).build();

응용 프로그램 컨텍스트에 바인딩
이 설정을 사용하면 Spring MVC 또는 Spring WebFlux 인프라 및 컨트롤러 선언을 사용하여 실행 중인 서버 없이 모의 요청 및 응답 개체를 통해 요청을 처리할 수 있습니다.

WebFlux의 경우, Spring Application Context가 WebHttpHandlerBuilder로 전달되어 요청을 처리할 WebHandler 체인을 작성합니다.

@SpringJUnitConfig(WebConfig.class) 
class MyTests {

    WebTestClient client;

    @BeforeEach
    void setUp(ApplicationContext context) {  
        client = WebTestClient.bindToApplicationContext(context).build(); 
    }
}

Spring Application Context가 MockMvcBuilder에게 전달될 경우 다음을 사용합니다.
WebAppContextSetup을 사용하여 요청을 처리할 MockMvc 인스턴스를 생성합니다.

@ExtendWith(SpringExtension.class)
@WebAppConfiguration("classpath:META-INF/web-resources") 
@ContextHierarchy({
    @ContextConfiguration(classes = RootConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class MyTests {

    @Autowired
    WebApplicationContext wac; 

    WebTestClient client;

    @BeforeEach
    void setUp() {
        client = MockMvcWebTestClient.bindToApplicationContext(this.wac).build(); 
    }
}





================================
MockMvc
MockMvc는 두 가지 방법 중 하나로 설정할 수 있습니다. 
하나는 테스트할 컨트롤러를 직접 가리키고 Spring MVC 인프라를 프로그래밍 방식으로 구성하는 것입니다. 
두 번째는 Spring MVC와 컨트롤러 인프라가 포함된 Spring 구성을 가리킵니다.

public class DemoControllerTest {

    MockMvc mockMvc;

    @BeforeEach
    void setUp() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new DemoController()).build();
    }

    @DisplayName("1")
    @Test
    void name() {
        Assertions.assertEquals(1, 1);
}




@SpringJUnitWebConfig
public class DemoControllerTest {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    @DisplayName("1")
    @Test
    void name() {
        Assertions.assertEquals(1, 1);
}


@ExtendWith(SpringExtension.class)
@WebAppConfiguration
public class DemoControllerTest {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    @DisplayName("1")
    @Test
    void name() {
        Assertions.assertEquals(1, 1);
}
