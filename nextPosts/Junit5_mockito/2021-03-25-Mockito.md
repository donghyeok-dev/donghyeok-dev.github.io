---
layout: customPost
title:  "Mockito"
categories: 
  - Spring
  - Test
---

##  Mockito

Mock: 진짜 객체와 비슷한 동작을 하지만 개발자가 직접 행동을 관리하는 객체.

Mockito : Mock 객체를 쉽게 만들고 관리하고 검증할 수 있는 방법을 제공하는 프레임워크이며 Mockito 이외에도 JMock, EasyMock 등이 있음.



spring boot는 기본적으로 spring-boot-starter-test가 dependencies에 포함되어 있고 아래와 같은 것들이 포함되어 있음.

```
testImplementation 'org.springframework.boot:spring-boot-starter-test'
```

- JUnit5
- Spring Test
- AssertJ
- Hamcrest
- Mockito
- JsonPath
- JSONassert



### 간단한 예제 

구현체가 없는  Service Interface에 정의된 함수를 Mockito를 이용해 테스트 하는 예제.

MockitoController.java

```java
package com.example.tdd1;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@Slf4j
public class MockitoController {

    private final MockitoService mockitoService;

    public MockitoController(MockitoService mockitoService) {
        this.mockitoService = mockitoService;
    }

    @GetMapping("/example1")
    public Integer example1(Integer value1, Integer value2) {
        return this.mockitoService.calculateValue(value1, value2);
    }

    @GetMapping("/example2")
    public List<MockitoDto> example2(MockitoDto dto) {
        return this.mockitoService.getDataList(dto);
    }
}

```

MockitoDto.java

```java
package com.example.tdd1;

import lombok.*;

@Getter
@Setter
@ToString
@NoArgsConstructor
@EqualsAndHashCode(of = {"name", "value1", "value2"})
public class MockitoDto {
    private String name;
    private Integer value1;
    private Integer value2;

    @Builder
    public MockitoDto(String name, Integer value1, Integer value2) {
        this.name = name;
        this.value1 = value1;
        this.value2 = value2;
    }
}
```

MockitoService.java

```java
package com.example.tdd1;

import java.util.List;

public interface MockitoService {
    public List<MockitoDto> getDataList(MockitoDto dto);
    
    public int calculateValue(int a, int b);
}
```

MockitoControllerTest.java

```java
package com.example.tdd1;


import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit.jupiter.web.SpringJUnitWebConfig;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.log;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringJUnitWebConfig
@ExtendWith(MockitoExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@Slf4j
class MockitoControllerTest {
    MockMvc mockMvc;
    ObjectMapper objectMapper;
    
    @Mock
    MockitoService mockitoService;
    
    private AutoCloseable closeable;

    @BeforeAll
    public void openMocks() {
        closeable = MockitoAnnotations.openMocks(this);
    }

    @BeforeEach
    void setUp() {
        this.objectMapper = new ObjectMapper();
        //this.mockitoService = mock(MockitoService.class);
        this.mockMvc = MockMvcBuilders.standaloneSetup(new MockitoController(mockitoService))
                .alwaysDo(log())
                .build();
    }

    @Test
    @DisplayName("mockito 기본 테스트")
    void test1() throws Exception {
        //given
        final int value1 = 3;
        final int value2 = 5;

        Mockito.when(this.mockitoService.calculateValue(value1, value2)).thenReturn(value1 * value2);

        //when
        MvcResult mvcResult = this.mockMvc.perform(get("/example1")
                .param("value1", String.valueOf(value1))
                .param("value2", String.valueOf(value2))).andReturn();

        //then
        Mockito.verify(this.mockitoService).calculateValue(value1, value2);
        Assertions.assertEquals(mvcResult.getResponse().getContentAsString(), String.valueOf(value1 * value2));
    }

    @Test
    @DisplayName("Mockito Answer 테스트")
    void test2() throws Exception {
        //given
        final MockitoDto dto = MockitoDto.builder()
                .value1(2)
                .value2(3)
                .name("spring")
                .build();

        List<MockitoDto> resultList = new ArrayList<>();
        resultList.add(dto);
        resultList.add(dto);
        resultList.add(dto);

//        Mockito.when(this.mockitoService.getDataList(Mockito.isA(MockitoDto.class))).thenReturn(resultList);
        Mockito.when(this.mockitoService.getDataList(Mockito.isA(MockitoDto.class))).then(invocation -> {
            log.info("answer call!");
            return resultList;
        });

        //when
        ResultActions resultActions = this.mockMvc.perform(get("/example2")
                .params(convertDtoToMultiValueMap(objectMapper, dto))
                .contentType(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON));

        //then
        resultActions.andExpect(status().isOk()); //http 상태코드 200(정상)인지 검사.
        resultActions.andExpect(jsonPath("$.[*].name", Matchers.everyItem(Matchers.notNullValue()))); //리턴 받은 json객체의 name필드 중 null값이 포함되어있는지 검사.

        ArgumentCaptor<MockitoDto> captor = ArgumentCaptor.forClass(MockitoDto.class);
        Mockito.verify(this.mockitoService).getDataList(captor.capture()); //호출된 메소드에 전달된 값 검증하기 (메소드 1번만 호출 허용)
        Assertions.assertEquals(dto, captor.getValue());

        /*
            public static <T> T verify(T mock, VerificationMode mode)
            public interface VerificationMode
            public class VerificationModeFactory
            public class Times implements VerificationInOrderMode, VerificationMode
         */
        Mockito.verify(this.mockitoService).getDataList(Mockito.isA(MockitoDto.class)); // 1번만 호출되었는지 검사
        Mockito.verify(this.mockitoService, Mockito.times(1)).getDataList(Mockito.isA(MockitoDto.class)); // 지정된 호출횟수 만큼 호출되었는지 검사
        Mockito.verify(this.mockitoService, Mockito.timeout(1)).getDataList(Mockito.isA(MockitoDto.class)); //비동기 코드를 테스트 시 지정된 시간 내에 메소드가 처리되는지
    }

    @AfterAll
    public void releaseMocks() throws Exception {
        closeable.close();
    }

    MultiValueMap<String, String> convertDtoToMultiValueMap(ObjectMapper objectMapper, Object dto) {
        try {
            MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
            params.setAll(objectMapper.convertValue(dto, new TypeReference<Map<String, String>>() {
            }));
            return params;
        } catch (Exception e) {
            throw new IllegalStateException("Url Parameter Convert Error");
        }
    }
}
```



### @Mock

Mock 객체를 만들어 주는 Annotation.

위에 예제에서 MockitoService mockitoService; 부분에 @Mock을 Annotated 하므로서 this.mockitoService = mock(MockitoService.class); 를 생략할 수 있다.



속성값

answer: 상호 작용에 대한 기본 대답을 지정합니다.

```java
Answers answer() default Answers.RETURNS_DEFAULTS;
예)
Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));
         Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));
      
//Below does exactly the same:
Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
```

stubOnly : 스텁 전용 모의는 메서드 호출을 기록하지 않으므로 메모리를 저장하지만 호출 확인을 허용하지 않습니다.

```java
boolean stubOnly() default false;
예)
List stubOnly = mock(List.class, withSettings().stubOnly());
```

name: 이름을 지정합니다.

```java
String name() default "";
예)
Foo foo = mock(Foo.class, withSettings().name("foo"));
      
//Below does exactly the same:
Foo foo = mock(Foo.class, "foo");
```

extraInterfaces: 모크가 구현해야 하는 추가 인터페이스를 지정합니다. 

```java
Class<?>[] extraInterfaces() default {};

예) 
Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));
      
//now, the mock implements extra interfaces, so following casting is possible:
Bar bar = (Bar) foo;
Baz baz = (Baz) foo;
```

serializable: Mock 직렬화 여부.

```java
boolean serializable() default false;

예) 
List serializableMock = mock(List.class, withSettings().serializable());
```

lenient: 엄격한 유효성검사를 생략할지 여부.

```java
boolean lenient() default false;

예)
Foo mock = mock(Foo.class, withSettings.lenient());
```



### @MockBean

```java
import org.springframework.boot.test.mock.mockito.MockBean;
```



### @InjectMocks

@Mock 등을 통해 Mock 객체로 등록된 것 중 @InjectMocks하려는 객체에  @Autowired 등으로 Injection하려는 객체가 있다면 자동으로 DI를 해줍니다.









